# AI Context - Hall of Fame Project

## üö® ATTENZIONE - LETTURA OBBLIGATORIA PER AI ASSISTANT

**Questo file deve essere letto AUTOMATICAMENTE da qualsiasi AI che lavora su questo progetto.**

---

## üìã CONFIGURAZIONE AUTOMATICA

### **Regole Obbligatorie**
Questo progetto segue regole SEVERE per mantenere qualit√† del codice. Leggi IMMEDIATAMENTE:
- **`.ai-development-rules.md`** - Regole NON negoziabili
- **`CODE_INSTRUCTIONS.md`** - Architettura tecnica obbligatoria

### **Architettura Corrente**
```javascript
// ORDINE CARICAMENTO OBBLIGATORIO:
CONSTANTS ‚Üí Utils ‚Üí ModalManager ‚Üí HtmlBuilder ‚Üí DisplayManager ‚Üí HallOfFameApp
```

### **Zero Tolerance Policy**
- ‚ùå **ZERO duplicazioni** - MAI duplicare codice, messaggi, HTML
- ‚ùå **ZERO hardcoding** - Tutti i testi in `CONSTANTS.MESSAGES`
- ‚ùå **ZERO bypass** - SEMPRE usare utility classes esistenti

---

## üîß CHECKLIST AUTOMATICA PRE-INTERVENTO

Prima di qualsiasi modifica, verifica:

### **1. Comprensione Architettura** ‚úì
- [ ] Ho letto `.ai-development-rules.md` completamente
- [ ] Conosco l'ordine: CONSTANTS ‚Üí Utils ‚Üí ModalManager ‚Üí HtmlBuilder ‚Üí DisplayManager ‚Üí HallOfFameApp
- [ ] So quale classe usare per ogni operazione

### **2. Verifica Esistente** ‚úì
- [ ] Ho controllato se esiste gi√† una funzione simile in Utils/HtmlBuilder/DisplayManager
- [ ] Ho verificato se il messaggio esiste gi√† in CONSTANTS.MESSAGES
- [ ] Ho confermato che non sto duplicando pattern esistenti

### **3. Pattern Compliance** ‚úì
- [ ] Uso `Utils.validateName()` per validazioni nomi
- [ ] Uso `ModalManager.setupModal()` per tutte le modali
- [ ] Uso `HtmlBuilder.*` per elementi UI comuni
- [ ] Uso `DisplayManager.*` per stati vuoti e liste

---

## üéØ QUICK REFERENCE

### **Validazione Nomi**
```javascript
// ‚úÖ SEMPRE cos√¨
try {
    Utils.validateName(name, existingItems, currentId, 'entityType');
} catch (error) {
    alert(error.message);
    return;
}
```

### **Gestione Modali**
```javascript
// ‚úÖ SEMPRE cos√¨
ModalManager.setupModal('entity', false);        // Add
ModalManager.setupModal('entity', true, data);   // Edit
```

### **Generazione HTML**
```javascript
// ‚úÖ SEMPRE cos√¨
HtmlBuilder.createButton('Testo', 'classe', callback, 'icona');
HtmlBuilder.createActionButtons(id, 'EntityType');
```

### **Stati Vuoti**
```javascript
// ‚úÖ SEMPRE cos√¨
DisplayManager.renderEmptyState(container, 'Messaggio');
```

### **Nuovi Messaggi**
```javascript
// ‚úÖ SEMPRE aggiungere in CONSTANTS
CONSTANTS.MESSAGES.NEW_MESSAGE = 'Testo con {placeholder}';
```

---

## ‚ö° AZIONI IMMEDIATE RICHIESTE

### **Se stai lavorando su:**

#### **üîπ Nuova Funzionalit√†**
1. Aggiungi configurazioni in `CONSTANTS`
2. Usa pattern esistenti in Utils/HtmlBuilder/DisplayManager
3. Segui workflow in `.ai-development-rules.md`

#### **üîπ Modifica Esistente**
1. Verifica impact su altri componenti
2. Mantieni pattern consolidati
3. Testa TUTTE le funzionalit√† correlate

#### **üîπ Bug Fix**
1. Identifica root cause nell'architettura
2. Fix centralizzato nelle utility classes
3. Verifica non introduca duplicazioni

---

## üö´ ERRORI FATALI DA EVITARE

### **‚ùå MAI fare questo:**
```javascript
// Hardcoding messaggi
alert('Errore durante salvataggio');

// Duplicazione validazioni
if (!name) { alert('Nome richiesto'); }

// Setup manuale modali
document.getElementById('modal-title').textContent = 'Titolo';

// Template HTML inline
const html = `<button class="btn">Click</button>`;

// Gestione manuale stati vuoti
container.innerHTML = '<div>Nessun elemento</div>';
```

### **‚úÖ SEMPRE fare cos√¨:**
```javascript
// Usare CONSTANTS
alert(CONSTANTS.MESSAGES.SAVE_ERROR);

// Usare Utils
Utils.validateName(name, items, id, 'type');

// Usare ModalManager
ModalManager.setupModal('entity', false);

// Usare HtmlBuilder
HtmlBuilder.createButton('Click', 'btn', callback);

// Usare DisplayManager
DisplayManager.renderEmptyState(container, message);
```

---

## üìû ESCALATION

Se non sei sicuro di come procedere:
1. **Studia** `.ai-development-rules.md` pi√π approfonditamente
2. **Analizza** pattern esistenti nel codice
3. **Chiedi conferma** invece di indovinare
4. **Proponi** soluzione seguendo architettura esistente

---

## üéØ OBIETTIVO FINALE

**Ogni modifica deve:**
- ‚úÖ Rispettare architettura modulare
- ‚úÖ Usare utility classes esistenti
- ‚úÖ Mantenere zero duplicazioni
- ‚úÖ Seguire pattern consolidati
- ‚úÖ Essere facilmente manutenibile

**Il successo si misura in: ZERO regressioni + MASSIMA consistenza + FACILIT√Ä estensione** 